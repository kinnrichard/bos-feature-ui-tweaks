# EP-0013: Migrate Activity Logging to Zero.js mutateBatch for Atomic Operations

## Epic Summary
Migrate all activity logging from separate transactions to atomic mutateBatch operations to resolve foreign key constraint violations and race conditions between parent record creation and activity log creation.

## Problem Statement
Currently, when creating records (e.g., Jobs) that have activity logging, the system creates two separate Zero.js mutations:
1. Insert the parent record (e.g., job)
2. Insert the activity log referencing the parent

This causes intermittent foreign key constraint violations when the activity log insert reaches PostgreSQL before the parent record, especially during offline/online sync operations.

## Solution Overview
Implement atomic activity logging using Zero.js `mutateBatch` API to ensure parent records and their activity logs are created in a single transaction.

## Acceptance Criteria
- [ ] Rails generator detects all models that include the `Loggable` concern
- [ ] Generator creates TypeScript configuration mapping Loggable models
- [ ] ActiveRecord base class uses `mutateBatch` for all Loggable models
- [ ] Activity logs are created atomically with parent records
- [ ] Foreign key constraint violations are eliminated
- [ ] System gracefully handles activity log failures without failing parent creation
- [ ] All existing Loggable models work with new implementation
- [ ] Integration tests verify atomic operations in online/offline scenarios

## Technical Design

### 1. Generator Detection of Loggable Models

Update `lib/generators/zero/active_models/generation_coordinator.rb` to:
```ruby
# Detect if model includes Loggable concern
def detect_loggable_models(model_class)
  model_class.included_modules.include?(Loggable)
end

# Generate configuration for TypeScript
def generate_loggable_config
  loggable_models = {}
  
  Rails.application.eager_load!
  ApplicationRecord.descendants.each do |model|
    if model.included_modules.include?(Loggable)
      loggable_models[model.table_name] = {
        modelName: model.name,
        includesLoggable: true
      }
    end
  end
  
  loggable_models
end
```

### 2. Generated TypeScript Configuration

Create `frontend/src/lib/models/generated-loggable-config.ts`:
```typescript
// ü§ñ AUTO-GENERATED LOGGABLE CONFIGURATION
// Generated at: 2025-07-31T00:00:00Z
// 
// ‚ö†Ô∏è  DO NOT EDIT THIS FILE DIRECTLY

export const LOGGABLE_MODELS = {
  'jobs': { modelName: 'Job', includesLoggable: true },
  'tasks': { modelName: 'Task', includesLoggable: true },
  'clients': { modelName: 'Client', includesLoggable: true },
  'users': { modelName: 'User', includesLoggable: true },
  'people': { modelName: 'Person', includesLoggable: true },
  'devices': { modelName: 'Device', includesLoggable: true },
  'scheduled_date_times': { modelName: 'ScheduledDateTime', includesLoggable: true }
} as const;

export function isLoggableModel(tableName: string): boolean {
  return tableName in LOGGABLE_MODELS;
}
```

### 3. Update Activity Logging Mutator

Modify `frontend/src/lib/shared/mutators/activity-logging.ts`:
```typescript
async function logActivity(
  data: Loggable,
  context: MutatorContext,
  config: ActivityLoggingConfig & typeof DEFAULT_ACTIVITY_LOGGING_CONFIG,
  currentUser: any
): Promise<void> {
  const action = determineAction(data, context, config);
  if (!action) {
    return;
  }

  const metadata = buildMetadata(data, context, config, action);
  
  const clientId = await Promise.resolve(config.getAssociatedClientId?.(data)) || null;
  const jobId = await Promise.resolve(config.getAssociatedJobId?.(data)) || null;
  
  // Store activity log data in context for batch creation
  context.pendingActivityLog = {
    user_id: currentUser.id,
    action,
    loggable_type: config.loggableType,
    loggable_id: data.id || '',
    metadata,
    client_id: clientId,
    job_id: jobId
  };
  
  // DO NOT create activity log here - let ActiveRecord handle it atomically
}
```

### 4. Update ActiveRecord Base Class

Modify `frontend/src/lib/models/base/active-record.ts`:
```typescript
import { LOGGABLE_MODELS, isLoggableModel } from '../generated-loggable-config';

async create(data: CreateData<T>, _options: QueryOptions = {}): Promise<T> {
  const zero = getZero();
  if (!zero) {
    throw new Error('Zero client not initialized');
  }

  const id = crypto.randomUUID();
  const now = this.currentTime();

  // ... existing processing ...

  // Apply mutators (including activity logging mutator)
  const mutatedData = await executeMutatorWithTracking(
    this.config.tableName,
    processedData,
    null,
    context,
    { trackChanges: false }
  );

  try {
    console.log(`[ActiveRecord] Creating ${this.config.tableName} with data:`, mutatedData);

    // Check if this model needs activity logging
    const needsActivityLog = isLoggableModel(this.config.tableName) && 
                            context.pendingActivityLog;

    if (needsActivityLog && context.pendingActivityLog) {
      // Use mutateBatch for atomic operation
      await zero.mutateBatch(async (tx) => {
        // Insert the main record
        await (tx as any)[this.config.tableName].insert(mutatedData);
        
        // Insert activity log in same transaction
        const activityLogData = {
          id: crypto.randomUUID(),
          created_at: now,
          updated_at: now,
          ...context.pendingActivityLog
        };
        
        try {
          await tx.activity_logs.insert(activityLogData);
        } catch (activityLogError) {
          // Log error but don't fail the parent creation
          console.error(`[ActiveRecord] Failed to create activity log for ${this.config.tableName}:`, activityLogError);
          // Continue - parent record will still be created
        }
      });
      console.log(`[ActiveRecord] Batch insert successful for ${this.config.tableName} with activity log`);
    } else {
      // Regular insert for non-loggable models
      await (zero.mutate as any)[this.config.tableName].insert(mutatedData);
      console.log(`[ActiveRecord] Insert successful for ${this.config.tableName}:`, id);
    }

    // ... rest of method
  } catch (error) {
    // ... existing error handling
  }
}
```

### 5. Update Model Mutators

Remove hardcoded model list from `frontend/src/lib/shared/mutators/model-mutators.ts` and use generated config:
```typescript
import { LOGGABLE_MODELS } from '../../models/generated-loggable-config';

// Dynamically build MODEL_MUTATORS based on Rails Loggable models
export const MODEL_MUTATORS: Record<string, MutatorFunction<any>> = {};

// Add activity logging mutators for Loggable models
Object.entries(LOGGABLE_MODELS).forEach(([tableName, config]) => {
  if (config.includesLoggable) {
    // Special handling for specific models
    switch (tableName) {
      case 'tasks':
        MODEL_MUTATORS[tableName] = taskMutatorPipeline;
        break;
      case 'jobs':
        MODEL_MUTATORS[tableName] = jobMutatorPipeline;
        break;
      case 'clients':
        MODEL_MUTATORS[tableName] = clientMutatorPipeline;
        break;
      case 'users':
        MODEL_MUTATORS[tableName] = userMutatorPipeline;
        break;
      default:
        // Generic activity logging for other Loggable models
        MODEL_MUTATORS[tableName] = createGenericLoggablePipeline(config.modelName);
    }
  }
});

// Add non-loggable models
['devices', 'people', 'scheduled_date_times', 'notes'].forEach(tableName => {
  if (!MODEL_MUTATORS[tableName]) {
    MODEL_MUTATORS[tableName] = genericMutatorPipeline;
  }
});
```

## Implementation Tasks

### Task 1: Update Rails Generator
- [ ] Add Loggable detection logic to generation coordinator
- [ ] Create template for generated-loggable-config.ts
- [ ] Update generator to write config file during generation
- [ ] Add tests for Loggable detection

### Task 2: Refactor Activity Logging Mutator
- [ ] Update mutator to store data in context instead of creating records
- [ ] Remove direct ActivityLog.create() calls
- [ ] Update mutator tests

### Task 3: Implement mutateBatch in ActiveRecord
- [ ] Import generated Loggable configuration
- [ ] Implement conditional mutateBatch logic
- [ ] Add error handling for activity log failures
- [ ] Update ActiveRecord tests

### Task 4: Update Model Mutators
- [ ] Remove hardcoded model lists
- [ ] Implement dynamic mutator registration
- [ ] Create generic loggable pipeline factory
- [ ] Update tests

### Task 5: Integration Testing
- [ ] Create test for atomic job + activity log creation
- [ ] Test offline scenario with sync
- [ ] Test activity log failure handling
- [ ] Test all Loggable models
- [ ] Verify foreign key constraints are satisfied

### Task 6: Migration & Cleanup
- [ ] Update all existing code to use new system
- [ ] Remove old activity logging code paths
- [ ] Update documentation
- [ ] Create migration guide

## Testing Strategy

### Unit Tests
- Generator correctly identifies Loggable models
- Mutator stores activity log data in context
- ActiveRecord uses mutateBatch for Loggable models
- Error handling when activity log fails

### Integration Tests
```typescript
test('creates job and activity log atomically', async () => {
  const job = await Job.create({
    title: 'Test Job',
    client_id: 'client-123'
  });
  
  // Verify both records exist
  const activityLogs = await ActivityLog.where({ 
    loggable_type: 'Job',
    loggable_id: job.id 
  }).all();
  
  expect(activityLogs.length).toBe(1);
  expect(activityLogs[0].action).toBe('created');
});

test('handles offline creation and sync', async () => {
  // Simulate offline
  await goOffline();
  
  const job = await Job.create({
    title: 'Offline Job',
    client_id: 'client-123'
  });
  
  // Simulate reconnection
  await goOnline();
  await waitForSync();
  
  // Verify no foreign key violations in logs
  expect(console.error).not.toHaveBeenCalledWith(
    expect.stringContaining('foreign key constraint')
  );
});

test('creates parent record even if activity log fails', async () => {
  // Mock activity log failure
  vi.spyOn(zero.mutate.activity_logs, 'insert').mockRejectedValueOnce(
    new Error('Activity log error')
  );
  
  const job = await Job.create({
    title: 'Test Job',
    client_id: 'client-123'
  });
  
  // Job should still be created
  expect(job.id).toBeDefined();
  expect(console.error).toHaveBeenCalledWith(
    expect.stringContaining('Failed to create activity log')
  );
});
```

## Success Metrics
- Zero foreign key constraint violations in production
- All Loggable models automatically configured
- No manual TypeScript configuration needed
- Seamless offline/online experience
- Activity log failures don't block parent creation

## Dependencies
- Zero.js mutateBatch API
- Rails model introspection
- TypeScript code generation

## Risks & Mitigations
- **Risk**: Generator performance with many models
  - **Mitigation**: Cache Loggable detection results
- **Risk**: Activity log creation failures in batch
  - **Mitigation**: Graceful error handling, log but continue
- **Risk**: Breaking existing functionality
  - **Mitigation**: Comprehensive test coverage before deployment

## Timeline
- Week 1: Generator updates and configuration generation
- Week 2: Activity logging refactor and ActiveRecord updates
- Week 3: Integration testing and bug fixes
- Week 4: Documentation and deployment

## Definition of Done
- [ ] All models with Loggable concern use mutateBatch
- [ ] No foreign key violations in test suite
- [ ] Generator automatically detects and configures Loggable models
- [ ] Integration tests pass for online/offline scenarios
- [ ] Documentation updated
- [ ] Code reviewed and approved
- [ ] Deployed to production with monitoring