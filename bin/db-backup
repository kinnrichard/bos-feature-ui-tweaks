#!/usr/bin/env bash

# PostgreSQL Database Backup Script for BOS Rails Application
# This script backs up the main (primary) database only

set -e

# Color output for better visibility
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Find pg_dump command
if command -v pg_dump &> /dev/null; then
  PG_DUMP="pg_dump"
  PG_RESTORE="pg_restore"
elif [ -f "/opt/homebrew/opt/postgresql@16/bin/pg_dump" ]; then
  PG_DUMP="/opt/homebrew/opt/postgresql@16/bin/pg_dump"
  PG_RESTORE="/opt/homebrew/opt/postgresql@16/bin/pg_restore"
elif [ -f "/opt/homebrew/opt/postgresql@15/bin/pg_dump" ]; then
  PG_DUMP="/opt/homebrew/opt/postgresql@15/bin/pg_dump"
  PG_RESTORE="/opt/homebrew/opt/postgresql@15/bin/pg_restore"
elif [ -f "/opt/homebrew/opt/postgresql@14/bin/pg_dump" ]; then
  PG_DUMP="/opt/homebrew/opt/postgresql@14/bin/pg_dump"
  PG_RESTORE="/opt/homebrew/opt/postgresql@14/bin/pg_restore"
elif [ -f "/usr/local/opt/postgresql@16/bin/pg_dump" ]; then
  PG_DUMP="/usr/local/opt/postgresql@16/bin/pg_dump"
  PG_RESTORE="/usr/local/opt/postgresql@16/bin/pg_restore"
else
  echo -e "${RED}Error: pg_dump not found!${NC}"
  echo "Please install PostgreSQL client tools:"
  echo "  brew install postgresql@16"
  echo "Or add PostgreSQL bin directory to your PATH"
  exit 1
fi

# Determine Rails environment (default to development)
RAILS_ENV="${RAILS_ENV:-development}"

# Set backup directory
BACKUP_DIR="${BACKUP_DIR:-${HOME}/backups/bos}"
DATE=$(date +%Y%m%d_%H%M%S)

# Database configuration from environment variables
DB_HOST="${DB_HOST:-localhost}"
DB_PORT="${DB_PORT:-5432}"
DB_USER="${DB_USER:-${USER}}"
DB_PASSWORD="${DB_PASSWORD:-}"

# Set database name based on environment
if [ "$RAILS_ENV" = "production" ]; then
  DB_NAME="${DB_NAME:-bos_production}"
elif [ "$RAILS_ENV" = "test" ]; then
  DB_NAME="bos_test"
else
  DB_NAME="${DB_NAME:-bos_development}"
fi

# Create backup directory if it doesn't exist
mkdir -p "${BACKUP_DIR}"

echo -e "${GREEN}=== BOS Database Backup ===${NC}"
echo -e "${YELLOW}Environment:${NC} ${RAILS_ENV}"
echo -e "${YELLOW}Database:${NC} ${DB_NAME}"
echo -e "${YELLOW}Host:${NC} ${DB_HOST}:${DB_PORT}"
echo -e "${YELLOW}Backup Directory:${NC} ${BACKUP_DIR}"
echo ""

# Set PGPASSWORD for non-interactive authentication if password is provided
if [ -n "$DB_PASSWORD" ]; then
  export PGPASSWORD="$DB_PASSWORD"
fi

# Backup filename
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${DATE}.dump"
BACKUP_LOG="${BACKUP_DIR}/${DB_NAME}_${DATE}.log"

# Perform the backup using custom format for better compression and flexibility
echo -e "${YELLOW}Starting backup...${NC}"
echo -e "${YELLOW}Using:${NC} ${PG_DUMP}"

if "${PG_DUMP}" \
  -h "${DB_HOST}" \
  -p "${DB_PORT}" \
  -U "${DB_USER}" \
  -d "${DB_NAME}" \
  -Fc \
  --verbose \
  --no-password \
  -f "${BACKUP_FILE}" 2> "${BACKUP_LOG}"; then
  # Get backup file size
  BACKUP_SIZE=$(du -h "${BACKUP_FILE}" | cut -f1)
  
  echo -e "${GREEN}✓ Backup completed successfully!${NC}"
  echo -e "${YELLOW}File:${NC} ${BACKUP_FILE}"
  echo -e "${YELLOW}Size:${NC} ${BACKUP_SIZE}"
  
  # Verify backup integrity
  echo -e "${YELLOW}Verifying backup integrity...${NC}"
  if "${PG_RESTORE}" --list "${BACKUP_FILE}" > /dev/null 2>&1; then
    echo -e "${GREEN}✓ Backup verification successful!${NC}"
  else
    echo -e "${RED}✗ Backup verification failed!${NC}"
    exit 1
  fi
  
  # Optional: Compress the backup further with gzip
  if [ "${COMPRESS_BACKUP}" = "true" ]; then
    echo -e "${YELLOW}Compressing backup...${NC}"
    gzip "${BACKUP_FILE}"
    BACKUP_FILE="${BACKUP_FILE}.gz"
    BACKUP_SIZE=$(du -h "${BACKUP_FILE}" | cut -f1)
    echo -e "${GREEN}✓ Compressed to ${BACKUP_SIZE}${NC}"
  fi
  
  # Clean up old backups (keep last 90 days by default, but ensure at least 10 backups remain)
  RETENTION_DAYS="${RETENTION_DAYS:-90}"
  MIN_BACKUPS="${MIN_BACKUPS:-10}"
  
  if [ "${RETENTION_DAYS}" -gt 0 ]; then
    # Count existing backups
    BACKUP_COUNT=$(find "${BACKUP_DIR}" -name "${DB_NAME}_*.dump*" -type f 2>/dev/null | wc -l | tr -d ' ')
    
    if [ "${BACKUP_COUNT}" -gt "${MIN_BACKUPS}" ]; then
      echo -e "${YELLOW}Cleaning up backups older than ${RETENTION_DAYS} days (keeping minimum ${MIN_BACKUPS} backups)...${NC}"
      
      # Get list of backups to potentially delete (older than RETENTION_DAYS)
      OLD_BACKUPS=$(find "${BACKUP_DIR}" -name "${DB_NAME}_*.dump*" -type f -mtime +${RETENTION_DAYS} 2>/dev/null | sort)
      
      if [ -n "${OLD_BACKUPS}" ]; then
        # Calculate how many we can safely delete
        DELETABLE_COUNT=$((BACKUP_COUNT - MIN_BACKUPS))
        
        if [ "${DELETABLE_COUNT}" -gt 0 ]; then
          # Delete old backups, but keep at least MIN_BACKUPS total
          echo "${OLD_BACKUPS}" | head -n "${DELETABLE_COUNT}" | while read -r backup_file; do
            rm -f "${backup_file}"
            # Also remove corresponding log file
            log_file="${backup_file%.dump*}.log"
            [ -f "${log_file}" ] && rm -f "${log_file}"
            echo -e "  Removed: $(basename "${backup_file}")"
          done
          echo -e "${GREEN}✓ Cleanup completed${NC}"
        else
          echo -e "${YELLOW}Skipping cleanup - would leave fewer than ${MIN_BACKUPS} backups${NC}"
        fi
      else
        echo -e "${YELLOW}No backups older than ${RETENTION_DAYS} days found${NC}"
      fi
    else
      echo -e "${YELLOW}Skipping cleanup - only ${BACKUP_COUNT} backups exist (minimum ${MIN_BACKUPS} required)${NC}"
    fi
  fi
  
  # Show recent backups
  echo ""
  echo -e "${YELLOW}Recent backups:${NC}"
  ls -lht "${BACKUP_DIR}/${DB_NAME}_"*.dump* 2>/dev/null | head -5 || echo "No backups found"
  
else
  echo -e "${RED}✗ Backup failed! Check the log file: ${BACKUP_LOG}${NC}"
  tail -20 "${BACKUP_LOG}"
  exit 1
fi

# Clean up environment
unset PGPASSWORD

echo ""
echo -e "${GREEN}=== Backup Complete ===${NC}"
echo ""
echo "To restore from this backup, use:"
echo "  ${PG_RESTORE} -h ${DB_HOST} -U ${DB_USER} -d ${DB_NAME} -v ${BACKUP_FILE}"
echo ""
echo "To restore to a different database:"
echo "  createdb -h ${DB_HOST} -U ${DB_USER} new_database"
echo "  ${PG_RESTORE} -h ${DB_HOST} -U ${DB_USER} -d new_database -v ${BACKUP_FILE}"