# frozen_string_literal: true

module Zero
  module Generators
    # Converts Rails default values to TypeScript-safe equivalents
    # Handles various Rails default patterns including UUID generation,
    # timestamps, and literal values
    class DefaultValueConverter
      # PostgreSQL function patterns that generate values at runtime
      RUNTIME_FUNCTIONS = {
        "gen_random_uuid()" => nil, # UUID generated by database
        "CURRENT_TIMESTAMP" => nil, # Timestamp generated by database
        "now()" => nil,             # Alternative timestamp function
        "uuid_generate_v4()" => nil # Alternative UUID function
      }.freeze

      # Maps Rails column types to TypeScript literal types
      TYPE_CONVERTERS = {
        string: ->(value) { convert_string_default(value) },
        text: ->(value) { convert_string_default(value) },
        integer: ->(value) { convert_numeric_default(value) },
        bigint: ->(value) { convert_numeric_default(value) },
        decimal: ->(value) { convert_numeric_default(value) },
        float: ->(value) { convert_numeric_default(value) },
        boolean: ->(value) { convert_boolean_default(value) },
        date: ->(value) { convert_date_default(value) },
        datetime: ->(value) { convert_datetime_default(value) },
        time: ->(value) { convert_time_default(value) },
        json: ->(value) { convert_json_default(value) },
        jsonb: ->(value) { convert_json_default(value) }
      }.freeze

      def initialize
        # No initialization needed
      end

      # Convert a column's default value to TypeScript
      # @param column [Hash] Column data from schema introspection
      # @return [String, nil] TypeScript literal or nil if no default
      def convert_default(column)
        return nil if column[:default].nil?

        # Handle runtime functions
        if runtime_function?(column[:default])
          return nil # These are handled by the database
        end

        # Get the appropriate converter for the column type
        converter = TYPE_CONVERTERS[column[:type]]
        return nil unless converter

        converter.call(column[:default])
      rescue StandardError => e
        Rails.logger.warn "Failed to convert default for column #{column[:name]}: #{e.message}"
        nil
      end

      # Generate TypeScript default object for a table
      # @param table_name [String] The table name
      # @param columns [Array<Hash>] Column data from schema introspection
      # @return [String, nil] TypeScript object literal or nil if no defaults
      def generate_defaults_object(table_name, columns)
        defaults = {}

        columns.each do |column|
          converted_value = convert_default(column)
          next if converted_value.nil?

          defaults[column[:name]] = converted_value
        end

        return nil if defaults.empty?

        format_typescript_object(defaults)
      end

      private

      def runtime_function?(value)
        return false unless value.is_a?(String)

        # Check if it's a lambda/proc string representation
        return true if value.include?("->") || value.include?("lambda")

        # Check against known runtime functions
        RUNTIME_FUNCTIONS.key?(value.strip)
      end

      def self.convert_string_default(value)
        # Handle nil or empty strings
        return "''" if value.nil? || value.empty?

        # Escape single quotes and return as TypeScript string literal
        "'#{value.gsub("'") { "\\'" }}'"
      end

      def self.convert_numeric_default(value)
        # Convert to number, handling various formats
        return "0" if value.nil?

        numeric_value = value.to_s.strip
        # Remove any surrounding quotes
        numeric_value = numeric_value.gsub(/^['"]|['"]$/, "")

        # Validate it's a valid number
        parsed = Float(numeric_value)
        # Return integer representation if it's a whole number
        parsed == parsed.to_i ? parsed.to_i.to_s : parsed.to_s
      rescue ArgumentError
        "0" # Default to 0 if conversion fails
      end

      def self.convert_boolean_default(value)
        # Handle various boolean representations
        case value
        when true, "true", "t", "1", 1
          "true"
        when false, "false", "f", "0", 0, nil
          "false"
        else
          "false" # Default to false for unknown values
        end
      end

      def self.convert_date_default(value)
        # Dates are typically stored as strings in TypeScript
        return "null" if value.nil?

        # If it's already a string date, quote it
        if value.is_a?(String) && value.match?(/\d{4}-\d{2}-\d{2}/)
          "'#{value}'"
        else
          "null" # Can't convert complex date expressions
        end
      end

      def self.convert_datetime_default(value)
        # Similar to date handling
        convert_date_default(value)
      end

      def self.convert_time_default(value)
        # Time values are typically strings
        convert_date_default(value)
      end

      def self.convert_json_default(value)
        # JSON defaults are typically empty objects or arrays
        case value
        when "{}"
          "{}"
        when "[]"
          "[]"
        when nil
          "null"
        else
          # Try to parse and re-stringify for valid JSON
          begin
            JSON.parse(value).to_json
          rescue JSON::ParserError
            "{}"
          end
        end
      end

      def format_typescript_object(defaults)
        # Sort keys for consistent output
        sorted_defaults = defaults.sort.to_h

        lines = sorted_defaults.map do |key, value|
          "  #{key}: #{value}"
        end

        "{\n#{lines.join(",\n")},\n}"
      end
    end
  end
end
